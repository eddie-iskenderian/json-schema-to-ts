#!/usr/bin/env node

import { JSONSchema4 } from 'json-schema';
import minimist = require('minimist');
import { readdir, readFile, writeFile } from 'mz/fs';
const fs = require('fs').promises;
import { join, resolve, extname } from 'path';
import * as _ from 'lodash';
import { compile } from './index';

const normaliseToken = (path: string): string => `\/${ path.replace(
    /(^[a-z]|_[a-z])/g,
    (str: string) => str.length === 1 ? str.toUpperCase() : str.charAt(1).toUpperCase()
  ).replace('.json', '') }`;

const pathMap: { [id: string]: string } = {};

const createPathMap = async (base: string, cwd: string) => {
  const schemas: string[] = await readdir(base);
  for (const schema of schemas) {
    const filePath = join(base, schema);
    const stats = await fs.stat(filePath);
    if (schema.startsWith('package')) {
      // Ignore npm files
    } else if (stats.isDirectory()) {
      await createPathMap(filePath, cwd);
    } else if (stats.isFile() && extname(schema) === '.json') {
      const schemaDef = require(filePath);
      console.log(schemaDef.id);
      // Generate the typescript
      const token = normaliseToken(schema); // `${ cwd }/${ normaliseToken(schema) }`;
      if (token in pathMap) {
        throw `Duplicate JSON Schema ${ filePath }`;
      }
      console.log(token);
      pathMap[token] = filePath;
    }
  }
};

const schemaReader = async (file: { url: string }, callback?: (error: Error | null, data: string | null) => string): Promise<string> => {
  console.log(file.url);
  const path: string = pathMap[file.url];
  const schema = await readInput(path);
  if (callback) {
    callback(null, schema);
  }
  return schema;
};

const getSchemas = async (base: string, cwd: string): Promise<string> => {
  const schemas: string[] = await readdir(base);
  const ts: string[] = [];
  for (const schema of schemas) {
    const filePath = join(base, schema);
    const stats = await fs.stat(filePath);
    if (stats.isDirectory()) {
      ts.push(await getSchemas(filePath, cwd));
    } else if (stats.isFile()) {
      if (!schema.endsWith('.json')) {
        continue;
      }
      const jsonSchema: JSONSchema4 = JSON.parse(await readInput(filePath));
      // Generate the typescript
      const definition = await compile(jsonSchema, filePath, cwd, schemaReader);
      ts.push(definition);
    }
  }
  return ts.filter(Boolean).join(`\n`);
};

const main = async (argv: minimist.ParsedArgs) => {
  if (argv.help) {
    printHelp();
    process.exit(0);
  }
  const argIn: string = argv._[0] || argv.input;
  const argOut: string = argv._[1] || argv.output;
  if (!argIn || !argOut) {
    console.log('Both input and output parameters are required.');
    process.exit(1);
  }

  try {
    await createPathMap(argIn, argIn);
    // Generate typescript for all of the JSON schemas in the input directory.
    const ts: string = await getSchemas(argIn, argIn);
    const bannerComment: string = `/**
 * This file was automatically generated by Slyp's json-schema to typescript generator.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the generator to regenerate this file.
 */`;
    // Write the accumulated typescript definitions to a typescript file.
    await writeFile(argOut, `${ bannerComment }\n${ ts }`);
  } catch (e) {
    console.error(e);
    process.exit(1);
  }
};

async function readInput(argIn: string): Promise<string> {
  return await readFile(resolve(process.cwd(), argIn), 'utf-8');
}

function printHelp() {
  const pkg = require('../../package.json');

  process.stdout.write(
    `
${pkg.name} ${pkg.version}
Usage: json2ts [--input, -i] [IN_FILE] [--output, -o] [OUT_FILE] [OPTIONS]

With no IN_FILE, or when IN_FILE is -, read standard input.
With no OUT_FILE and when IN_FILE is specified, create .d.ts file in the same directory.
With no OUT_FILE nor IN_FILE, write to standard output.

You can use any of the following options by adding them at the end.
Boolean values can be set to false using the 'no-' prefix.

  --cwd=XXX
      Root directory for resolving $ref
  --style.XXX=YYY
      Prettier configuration
`
  );
}

main(minimist(process.argv.slice(2), { alias: { help: ['h'], input: ['i'], output: ['o'] } }));
